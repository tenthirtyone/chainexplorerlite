<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/reporter/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/reporter/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { sharedCache } = require("../cache");
const Logger = require("../logger");
const DB = require("../db");

class Reporter {
  /**
   * Retrieves, assembles, and parses block data from
   * the sharedCache
   * @param  {Object} config
   */
  constructor(config) {
    this.logger = new Logger("Reporter");
    this.config = { ...config };
    this.sharedCache = sharedCache;
    this.db = new DB();
  }
  /**
   * DEPRECATED
   * In my planning/design I accounted for ->
   * Reports hasMany Blocks hasMany Transactions.
   * I decided not to persist the reports, but
   * left the models and DB schema in place as a
   * jumping point for suggested feature.
   */
  createReportId() {
    return Math.round(Math.random() * 1e18);
  }
  /**
   * Assembles the report from the cached data
   * @param  {integer} startBlock
   * @param  {integer} endBlock
   */
  async createReport(startBlock, endBlock) {
    this.logger.info(`creating report for ${startBlock}-${endBlock}`);
    let data = [];
    try {
      data = await this.getReportData(startBlock, endBlock);
    } catch (e) {
      this.logger.error(e);
    }
    return { startBlock, endBlock, ...this.parseReportData(data) };
  }
  /**
   * I decided to handle this in the reporter rather than in the client
   * because I am supporting the CLI and web GUI. At scale and for large
   * reports sensible defaults and worker pools could stop a DoS that
   * blocks the event loop.
   *
   * Also, because report data will rarely change, a persisting/caching
   * strategy could reduce duplicate work at scale for users calling the
   * same reporting parameters.
   * @param  {Array} data
   */
  parseReportData(data) {
    const addresses = [];

    const senders = {};
    const receivers = {};
    const contracts = [];

    let summary = {
      totalSent: 0,
      totalUncles: 0,
      uniqueSenders: 0,
      uniqueReceivers: 0,
      contractsCreated: 0,
      uniqueAddresses: 0,
    };

    data.forEach((block) => {
      summary.totalUncles += block.uncles;

      block.transactions?.forEach((tx) => {
        summary.totalSent += parseInt(tx.value);

        // Null addr = contract created (0x000...)
        if (tx.to === null) {
          summary.contractsCreated++;
        } else {
          senders[tx.from] === undefined
            ? (senders[tx.from] = parseInt(tx.value))
            : (senders[tx.from] += parseInt(tx.value));
        }

        receivers[tx.to] === undefined
          ? (receivers[tx.to] = parseInt(tx.value))
          : (receivers[tx.to] += parseInt(tx.value));

        // 0x by default, contract call data check
        if (tx.input.length > 2) {
          contracts.push(tx.to);
        }

        // unique addrs
        addresses[tx.to] = true;
        addresses[tx.from] = true;
      });
    });

    summary.uniqueSenders = Object.keys(senders).length;
    summary.uniqueReceivers = Object.keys(receivers).length;
    summary.uniqueAddresses = Object.keys(addresses).length;

    summary.totalSent = summary.totalSent / 1e18;

    return {
      summary,
      senders,
      receivers,
      contracts,
    };
  }
  /**
   * Retrieves block data from the sharedCache
   * @param  {Integer} startBlock
   * @param  {Integer} endBlock
   */
  async getReportData(startBlock, endBlock) {
    if (startBlock > endBlock) {
      throw new Error("endblock is before startblock");
    }

    const data = [];

    let current = startBlock;
    while (current &lt;= endBlock) {
      if (this.sharedCache.exists(current)) {
        const block = await this.sharedCache.get(current);
        data.push(block);
      }

      current++;
    }

    return data;
  }

  static get DEFAULTS() {
    return {};
  }
}

module.exports = Reporter;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="API.html">API</a></li><li><a href="Cache.html">Cache</a></li><li><a href="DB.html">DB</a></li><li><a href="Explorer.html">Explorer</a></li><li><a href="Infura.html">Infura</a></li><li><a href="Logger.html">Logger</a></li><li><a href="Reporter.html">Reporter</a></li></ul><h3>Global</h3><ul><li><a href="global.html#logRequest">logRequest</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Mon Oct 11 2021 14:28:05 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
