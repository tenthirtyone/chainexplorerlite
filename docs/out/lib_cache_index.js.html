<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/cache/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/cache/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const LRU = require("lru-cache");
const DB = require("../db");
const Logger = require("../logger");
const { oneDay } = require("../util/constants");

class Cache {
  /**
   * Block objects are stored with their transactions in a
   * a shared cache. Intended to simulate Redis or comparable
   * cache service.
   * @param  {Object} config
   */
  constructor(config) {
    this.config = { ...Cache.DEFAULTS, ...config };
    this.logger = new Logger("Cache");
    this.lru = new LRU(this.config.lru);
    this.db = new DB();
    this.highestBlock = -1;
  }
  /**
   * Adds val to the cache at key
   * @param  {Integer} key
   * @param  {Object} val
   */
  add(key, val) {
    if (this.highestBlock &lt; key) {
      this.highestBlock = key;
    }

    this.lru.set(key, val);
  }

  /**
   * Returns the stored value at key
   * @param  {Integer} key
   */
  get(key) {
    return this.lru.get(key);
  }

  /**
   * Removes key from cache, sharedCache will never delete
   * otherwise highestBlock may need to be checked/replaced.
   * @param  {Integer} key
   */
  delete(key) {
    this.lru.del(key);
  }
  /**
   * Checks for an object at key
   * @param  {Integer} key
   */
  exists(key) {
    return this.lru.has(key);
  }
  /**
   * On startup, load stored block data into the cache
   */
  async populateCache() {
    const { cacheLimit } = this.config;
    let blocks = [];

    try {
      blocks = await this.db.Block.findAll({
        include: this.db.Transaction,
        limit: cacheLimit,
      });

      blocks.forEach((block) => {
        this.add(block.number, block);
      });
    } catch (e) {
      this.logger.error(
        "Error Populating Cache - if this is the first run/no blocks table it is safe to ignore this"
      );
    }
  }

  static get DEFAULTS() {
    return {
      cacheLimit: 1e10,
      lru: {
        max: 1e6,
        dispose: function (key, n) {
          n = "";
        },
        maxAge: oneDay,
      },
    };
  }
}

const sharedCache = new Cache();
sharedCache.populateCache();

module.exports = {
  sharedCache, // Singleton
  Cache,
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="API.html">API</a></li><li><a href="Cache.html">Cache</a></li><li><a href="DB.html">DB</a></li><li><a href="Explorer.html">Explorer</a></li><li><a href="Infura.html">Infura</a></li><li><a href="Logger.html">Logger</a></li><li><a href="Reporter.html">Reporter</a></li></ul><h3>Global</h3><ul><li><a href="global.html#logRequest">logRequest</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Mon Oct 11 2021 14:28:05 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
