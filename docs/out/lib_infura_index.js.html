<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/infura/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/infura/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Web3 = require("web3-eth");
const Logger = require("../logger");
const { oneSecond } = require("../util/constants");
const { Cache, sharedCache } = require("../cache");
const DB = require("../db");

class Infura {
  /**
   * Infura / Block service. Utilizes web3 to listen for
   * new blocks, index and save them to cache/DB. Runs
   * as close to Ethereum's TPS as possible or faster.
   *
   * @param  {Object} config
   */
  constructor(config) {
    this.db = new DB();
    this.config = { ...Infura.DEFAULTS, ...config };
    this.logger = new Logger("Infura");
    this.cache = new Cache();
    this.sharedCache = sharedCache;
    this.eventLoop = null;
    this.queue = [];
    this.web3 = null;
    this.listener = null;

    this.initWeb3();
  }
  /**
   * Establish a socket connection with the infura provider.
   * TODO: make this a block service with generic provider strings
   * for better node/network support
   */
  initWeb3() {
    this.web3 = new Web3(
      new Web3.providers.WebsocketProvider(
        `wss://mainnet.infura.io/ws/v3/${this.config.projectId}`
      )
    );
  }

  /**
   * This service is scheduled to run as close to Ethereum's TPS
   * as possible, or faster. It will establish a listener for new
   * blocks that are mined and add new work into it's queue.
   */
  start() {
    const { eventLoopTimer } = this.config;

    this.initWeb3();

    this.listener = this.web3.subscribe("newBlockHeaders", (err, header) => {
      this.addBlockToQueue(header.number);
    });

    this.eventLoop = setInterval(async () => {
      if (this.queue.length > 0) {
        const job = this.queue.shift();
        job.cb(await this.web3[job.op](job.params));
      }
    }, eventLoopTimer);
  }
  /**
   * Stop the service
   */
  stop() {
    this.web3?.currentProvider.connection.close();
    this.listener?.unsubscribe();
    clearInterval(this.eventLoop);
  }
  /**
   * Adds a block into the work queue for indexing by block number.
   * If the block already exists in the temp cache, or sharedCache,
   * it is ignored as it has already been indexed.
   * TODO: I left handling of reorgs out of scope for this project.
   * @param  {Integer} number
   */
  addBlockToQueue(number) {
    if (this.cache.exists(number) || this.sharedCache.exists(number)) return;

    this.logger.info(`Adding block ${number} to work queue`);
    this.queue.push({
      op: "getBlock",
      params: number,
      cb: (block) => {
        this.cache.add(number, block);
        block.transactions.forEach((hash) => {
          this.addTxToQueue(hash);
        });
        block.totalTx = block.transactions.length;
        block.transactions = [];
      },
    });
  }
  /**
   * Adds a blocks transactions into the work queue. If all txs have
   * been processed, save the block to the database.
   * @param  {String} hash
   */
  addTxToQueue(hash) {
    this.queue.push({
      op: "getTransaction",
      params: hash,
      cb: (tx) => {
        if (this.cache.exists(tx.blockNumber)) {
          const block = this.cache.get(tx.blockNumber);

          block.transactions.push(tx);
          if (block.totalTx === block.transactions.length) {
            this.saveBlockToDB(block);
          }
        }
      },
    });
  }
  /**
   * After the Infura service fetches the block &amp; tx
   * data it persists and associates then in the db.
   * It removes the block from the temp/local cache
   * and moves it into the sharedCache
   * @param  {Object} block
   */
  async saveBlockToDB(block) {
    const { Block, Transaction } = this.db;
    block.uncles = block.uncles.length || 0;
    let b = Block.build({
      ...block,
    });

    await b.save();

    block.transactions.forEach(async (tx) => {
      await Transaction.build({ ...tx }).save();
    });

    await b.save();

    this.sharedCache.add(b.number, block);
    this.cache.delete(b.number);
    this.logger.info(`Saved &amp; cached ${b.number}`);
  }
  /**
   * returns 'latest' block number from Infura
   */
  async getLatestBlockNumber() {
    return (await this.web3.getBlock("latest")).number;
  }
  /**
   * Convenience function to assist in pre-loading the
   * application.
   * Assumption: A Production system would fetch blocks
   * in parallel and require a similar function.
   * @param  {Integer} count
   */
  async fetchLastNBlocks(count) {
    let currentBlock = await this.getLatestBlockNumber();

    for (let i = currentBlock; i > currentBlock - count; i--) {
      setTimeout(() => {
        this.addBlockToQueue(i);
      });
    }
  }

  static get DEFAULTS() {
    return {
      eventLoopTimer: oneSecond / (process.env.INFURA_TPS || 15),
      projectId: process.env.INFURA_PROJECT_ID,
    };
  }
}

module.exports = Infura;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="API.html">API</a></li><li><a href="Cache.html">Cache</a></li><li><a href="DB.html">DB</a></li><li><a href="Explorer.html">Explorer</a></li><li><a href="Infura.html">Infura</a></li><li><a href="Logger.html">Logger</a></li><li><a href="Reporter.html">Reporter</a></li></ul><h3>Global</h3><ul><li><a href="global.html#logRequest">logRequest</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Mon Oct 11 2021 14:28:05 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
